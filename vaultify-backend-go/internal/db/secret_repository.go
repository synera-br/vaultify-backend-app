package db

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv" // For pagination

	"cloud.google.com/go/firestore"
	"google.golang.org/api/iterator"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"vaultify-backend-go/internal/models"
)

const secretsSubCollection = "secrets" // Subcollection under a vault document

// firestoreSecretRepository implements the SecretRepository interface using Firestore.
type firestoreSecretRepository struct {
	client *firestore.Client
}

// NewFirestoreSecretRepository creates a new instance of firestoreSecretRepository.
func NewFirestoreSecretRepository(client *firestore.Client) SecretRepository {
	if client == nil {
		log.Fatal("Firestore client is not initialized for SecretRepository.")
	}
	return &firestoreSecretRepository{client: client}
}

// secretsColRef is a helper to get the reference to the secrets subcollection for a given vault.
func (r *firestoreSecretRepository) secretsColRef(vaultID string) *firestore.CollectionRef {
	if vaultID == "" { // Should be caught by service layer, but good to be safe
		log.Println("Error: vaultID is empty in secretsColRef") // Or panic, as this is a programming error
		// Returning a nil or dummy ref would lead to obscure errors later.
		// For now, let client.Collection handle the empty path if it occurs.
	}
	return r.client.Collection(vaultsCollection).Doc(vaultID).Collection(secretsSubCollection)
}

// Create adds a new secret document to a vault's secrets subcollection in Firestore.
// The document ID is auto-generated by Firestore.
func (r *firestoreSecretRepository) Create(ctx context.Context, vaultID string, secret *models.Secret) (string, error) {
	if vaultID == "" {
		return "", errors.New("vaultID cannot be empty for creating a secret")
	}
	colRef := r.secretsColRef(vaultID)
	docRef := colRef.NewDoc()
	secret.ID = docRef.ID // Set the ID in the model before saving

	// CreatedAt and UpdatedAt are handled by serverTimestamp tags
	_, err := docRef.Create(ctx, secret)
	if err != nil {
		return "", fmt.Errorf("failed to create secret in vault '%s': %w", vaultID, err)
	}
	return docRef.ID, nil
}

// GetByID retrieves a secret document from a vault's secrets subcollection by its ID.
func (r *firestoreSecretRepository) GetByID(ctx context.Context, vaultID, secretID string) (*models.Secret, error) {
	if vaultID == "" || secretID == "" {
		return nil, errors.New("vaultID and secretID cannot be empty for GetByID operation")
	}
	docSnap, err := r.secretsColRef(vaultID).Doc(secretID).Get(ctx)
	if err != nil {
		if status.Code(err) == codes.NotFound {
			return nil, fmt.Errorf("secret with ID '%s' not found in vault '%s': %w", secretID, vaultID, ErrNotFound)
		}
		return nil, fmt.Errorf("failed to get secret '%s' from vault '%s': %w", secretID, vaultID, err)
	}

	var secret models.Secret
	if err := docSnap.DataTo(&secret); err != nil {
		return nil, fmt.Errorf("failed to decode secret data (ID: '%s', Vault: '%s'): %w", secretID, vaultID, err)
	}
	secret.ID = docSnap.Ref.ID // Ensure ID is populated
	secret.VaultID = vaultID  // Populate VaultID for context

	return &secret, nil
}

// GetByVaultID retrieves all secrets from a vault's secrets subcollection.
// Basic pagination support for "limit" and "startAfter" (document ID).
func (r *firestoreSecretRepository) GetByVaultID(ctx context.Context, vaultID string, paginationParams map[string]string) ([]*models.Secret, error) {
	if vaultID == "" {
		return nil, errors.New("vaultID cannot be empty for GetByVaultID operation")
	}

	query := r.secretsColRef(vaultID).OrderBy("createdAt", firestore.Desc) // Default order

	if limitStr, ok := paginationParams["limit"]; ok {
		if limit, err := strconv.Atoi(limitStr); err == nil && limit > 0 {
			query = query.Limit(limit)
		}
	}
	if startAfterDocID, ok := paginationParams["startAfter"]; ok && startAfterDocID != "" {
		startAfterSnap, err := r.secretsColRef(vaultID).Doc(startAfterDocID).Get(ctx)
		if err == nil {
			query = query.StartAfter(startAfterSnap)
		} else {
			log.Printf("Warning: Could not fetch startAfter document '%s' in vault '%s': %v. Pagination may be affected.", startAfterDocID, vaultID, err)
		}
	}

	iter := query.Documents(ctx)
	defer iter.Stop()

	var secrets []*models.Secret
	for {
		doc, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("failed to iterate secrets for vault '%s': %w", vaultID, err)
		}

		var secret models.Secret
		if err := doc.DataTo(&secret); err != nil {
			log.Printf("Error decoding secret data (ID: %s, Vault: %s): %v. Skipping.", doc.Ref.ID, vaultID, err)
			continue
		}
		secret.ID = doc.Ref.ID
		secret.VaultID = vaultID // Populate VaultID for context
		secrets = append(secrets, &secret)
	}
	return secrets, nil
}

// Update modifies an existing secret document in a vault's secrets subcollection.
func (r *firestoreSecretRepository) Update(ctx context.Context, vaultID string, secret *models.Secret) error {
	if vaultID == "" || secret.ID == "" {
		return errors.New("vaultID and secret.ID cannot be empty for Update operation")
	}
	// UpdatedAt is handled by serverTimestamp tag
	_, err := r.secretsColRef(vaultID).Doc(secret.ID).Set(ctx, secret, firestore.MergeAll)
	if err != nil {
		return fmt.Errorf("failed to update secret '%s' in vault '%s': %w", secret.ID, vaultID, err)
	}
	return nil
}

// Delete removes a secret document from a vault's secrets subcollection.
func (r *firestoreSecretRepository) Delete(ctx context.Context, vaultID, secretID string) error {
	if vaultID == "" || secretID == "" {
		return errors.New("vaultID and secretID cannot be empty for Delete operation")
	}
	_, err := r.secretsColRef(vaultID).Doc(secretID).Delete(ctx)
	if err != nil {
		if status.Code(err) == codes.NotFound {
			return fmt.Errorf("secret '%s' not found in vault '%s' for deletion: %w", secretID, vaultID, ErrNotFound)
		}
		return fmt.Errorf("failed to delete secret '%s' from vault '%s': %w", secretID, vaultID, err)
	}
	return nil
}

// DeleteByVaultID deletes all documents in a vault's secrets subcollection.
// This iterates through documents and deletes them. For very large subcollections,
// this can be slow and costly. Consider Cloud Functions for bulk deletion if performance becomes an issue.
func (r *firestoreSecretRepository) DeleteByVaultID(ctx context.Context, vaultID string) error {
	if vaultID == "" {
		return errors.New("vaultID cannot be empty for DeleteByVaultID operation")
	}

	// For simplicity, iterate and delete. For production, use BulkWriter for better performance and atomicity.
	// Note: Firestore does not guarantee atomicity for this kind of multi-document operation by default.
	// If atomicity is critical, a transaction or batched writes with careful error handling is needed,
	// but transactions have limits on the number of writes. BulkWriter is generally preferred for bulk ops.

	// Simple iterative delete:
	iter := r.secretsColRef(vaultID).Documents(ctx)
	var errorMessages []string
	var docsToDelete []*firestore.DocumentRef

	for {
		doc, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return fmt.Errorf("failed to list secrets for deletion in vault '%s': %w", vaultID, err)
		}
		docsToDelete = append(docsToDelete, doc.Ref)
	}

	if len(docsToDelete) == 0 {
		return nil // No secrets to delete
	}

	// Using BulkWriter for more efficient deletion
	bulkWriter := r.client.BulkWriter(ctx)
	for _, docRef := range docsToDelete {
		_, err := bulkWriter.Delete(docRef) // Enqueue delete operation
		if err != nil {
			// Log and collect errors. Depending on requirements, might continue or stop.
			errorMessages = append(errorMessages, fmt.Sprintf("failed to enqueue delete for secret %s: %v", docRef.ID, err))
		}
	}

	bulkWriter.Flush() // Commit all enqueued operations. Important to call this.
	// bulkWriter.End() can also be used, which calls Flush and waits for all writes. After flushing, check for errors.

	if len(errorMessages) > 0 {
		// Join the collected error messages into a single string.
		// This provides a summary of errors encountered during the bulk delete.
		return fmt.Errorf("encountered one or more errors during bulk deletion of secrets in vault '%s': %s", vaultID, strings.Join(errorMessages, "; "))
	}

	log.Printf("Successfully deleted %d secrets from vault '%s'", len(docsToDelete), vaultID)
	return nil
}


// CountByVaultID counts the number of secrets in a vault's secrets subcollection.
func (r *firestoreSecretRepository) CountByVaultID(ctx context.Context, vaultID string) (int, error) {
	if vaultID == "" {
		return 0, errors.New("vaultID cannot be empty for CountByVaultID operation")
	}
	// Similar to VaultRepository.CountByOwnerID, using GetAll() for simplicity.
	// Consider aggregation queries for very large subcollections.
	// aggQuery := r.secretsColRef(vaultID).NewAggregationQuery().WithCount("all")
	// results, err := aggQuery.Get(ctx) // ... handle results ...

	iter := r.secretsColRef(vaultID).Documents(ctx)
	defer iter.Stop()

	count := 0
	for {
		_, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return 0, fmt.Errorf("failed to iterate secrets for counting in vault '%s': %w", vaultID, err)
		}
		count++
	}
	return count, nil
}
