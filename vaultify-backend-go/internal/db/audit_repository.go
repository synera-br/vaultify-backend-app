package db

import (
	"context"
	"fmt"
	"log" // For constructor error logging

	"cloud.google.com/go/firestore"
	"vaultify-backend-go/internal/models"
	// No need for "google.api.services/googleidentitytoolkit/v3" for basic Firestore ops
)

const auditLogsCollection = "auditLogs"

// firestoreAuditRepository implements the AuditRepository interface using Firestore.
type firestoreAuditRepository struct {
	client *firestore.Client
}

// NewFirestoreAuditRepository creates a new instance of firestoreAuditRepository.
// It requires a non-nil Firestore client.
func NewFirestoreAuditRepository(client *firestore.Client) AuditRepository {
	if client == nil {
		// This is a critical setup error. Panicking or fatal logging is appropriate
		// as the application cannot function correctly without a db client if this repo is used.
		log.Fatal("Firestore client is not initialized for AuditRepository. Ensure InitFirestore was called and succeeded.")
	}
	return &firestoreAuditRepository{client: client}
}

// Create adds a new audit log entry to Firestore.
// The document ID is auto-generated by Firestore.
// The Timestamp field in models.AuditLog is expected to be populated by Firestore server-side.
func (r *firestoreAuditRepository) Create(ctx context.Context, logEntry models.AuditLog) error {
	// The logEntry.ID field is ignored by Firestore due to `firestore:"-"` tag.
	// Firestore will automatically generate a document ID.
	// The logEntry.Timestamp field should be set by serverTimestamp tag.
	// If logEntry.Timestamp was set client-side, serverTimestamp overrides it.

	_, err := r.client.Collection(auditLogsCollection).NewDoc().Create(ctx, logEntry)
	if err != nil {
		// TODO: Consider more specific error handling or wrapping if needed.
		// For example, distinguish between transient errors (retryable) and permanent ones.
		return fmt.Errorf("failed to create audit log entry in Firestore for action '%s', user '%s': %w", logEntry.Action, logEntry.UserID, err)
	}

	return nil
}
